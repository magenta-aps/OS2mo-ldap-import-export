# SPDX-FileCopyrightText: 2019-2020 Magenta ApS
# SPDX-License-Identifier: MPL-2.0
"""Integration tests fixtures."""
import asyncio
import warnings
from collections.abc import AsyncIterator
from typing import Awaitable
from typing import Callable
from typing import cast

import pytest
from asgi_lifespan import LifespanManager
from fastapi import FastAPI
from fastramqpi.context import Context
from fastramqpi.main import FastRAMQPI
from fastramqpi.ramqp import AMQPSystem
from httpx import ASGITransport
from httpx import AsyncClient
from ldap3 import Connection
from ldap3 import NO_ATTRIBUTES

from mo_ldap_import_export.autogenerated_graphql_client import GraphQLClient
from mo_ldap_import_export.depends import Settings
from mo_ldap_import_export.ldap import ldap_delete
from mo_ldap_import_export.ldap import ldap_search
from mo_ldap_import_export.main import create_app
from mo_ldap_import_export.main import create_fastramqpi
from mo_ldap_import_export.types import DN


@pytest.fixture
async def fastramqpi() -> FastRAMQPI:
    return create_fastramqpi()


@pytest.fixture
async def app(fastramqpi: FastRAMQPI) -> FastAPI:
    return create_app(fastramqpi=fastramqpi)


@pytest.fixture
async def lifespan_app(app: FastAPI) -> AsyncIterator[FastAPI]:
    """ASGI app with lifespan run."""
    async with LifespanManager(app) as manager:
        yield cast(FastAPI, manager.app)


@pytest.fixture
async def context(lifespan_app: FastAPI, fastramqpi: FastRAMQPI) -> Context:
    """FastRAMQPI context after lifespan has been run."""
    return fastramqpi._context


@pytest.fixture
async def test_client(lifespan_app: FastAPI) -> AsyncIterator[AsyncClient]:
    """Create ASGI test client with associated lifecycles."""
    transport = ASGITransport(app=lifespan_app, client=("1.2.3.4", 123))  # type: ignore
    async with AsyncClient(
        transport=transport, base_url="http://example.com"
    ) as client:
        yield client


@pytest.fixture
async def graphql_client(context: Context) -> GraphQLClient:
    """Authenticated GraphQL codegen client for OS2mo."""
    return cast(GraphQLClient, context["graphql_client"])


@pytest.fixture
async def amqpsystem(context: Context) -> AMQPSystem:
    """The MO AMQPSystem."""
    return cast(AMQPSystem, context["amqpsystem"])


@pytest.fixture
async def ldap_connection(context: Context) -> Connection:
    """The integration LDAP connection"""
    return cast(Connection, context["user_context"]["ldap_connection"])


@pytest.fixture
def get_num_queued_messages(
    rabbitmq_management_client: AsyncClient,
) -> Callable[[], Awaitable[int]]:
    """Get number of queued messages in RabbitMQ AMQP."""

    async def _get_num_queued_messages() -> int:
        queues = (await rabbitmq_management_client.get("queues")).json()
        return sum(
            queue.get("messages_ready", 0) + queue.get("messages_unacknowledged", 0)
            for queue in queues
        )

    return _get_num_queued_messages


@pytest.fixture(autouse=True)
async def purge_ldap(ldap_connection: Connection) -> AsyncIterator[None]:
    def entry2dn(entry) -> DN:
        assert entry["type"] == "searchResEntry"
        dn = entry.get("attributes", {}).get("distinguishedName", None)
        dn = dn or entry.get("dn", None)
        assert dn is not None
        assert isinstance(dn, DN)
        return dn

    async def find_all_dns() -> set[DN]:
        settings = Settings()
        searchParameters = {
            "search_filter": "(objectclass=*)",
            "attributes": NO_ATTRIBUTES,
            "search_base": settings.ldap_search_base,
        }
        response, result = await ldap_search(ldap_connection, **searchParameters)
        assert result["description"] == "success"
        dns = set(map(entry2dn, response))
        dns.discard(settings.ldap_search_base)  # root attribute is kept
        return dns

    async def delete_all_dns() -> None:
        # Keep deleting dns until none are left
        dns = await find_all_dns()
        while dns:
            # This will attempt to delete as many DNs as possible
            # However due to dependencies some deletes may fail
            # TODO: Intelligently decide what to delete at each iteration?
            await asyncio.gather(*[ldap_delete(ldap_connection, dn) for dn in dns])

            # If we did not manage to delete anything, we are stuck
            # Perhaps there are cyclic dependencies at play?
            new_dns = await find_all_dns()
            if new_dns == dns:
                pytest.fail(f"Unable to clear LDAP database before test: {new_dns}")
            dns = new_dns

    dns = await find_all_dns()
    if dns:
        warnings.warn(f"LDAP database not empty at testing start: {dns}")

    await delete_all_dns()
    yield
    await delete_all_dns()
