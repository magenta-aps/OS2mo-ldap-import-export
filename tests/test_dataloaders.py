# SPDX-FileCopyrightText: 2019-2020 Magenta ApS
# SPDX-License-Identifier: MPL-2.0
# pylint: disable=redefined-outer-name
# pylint: disable=unused-argument
# pylint: disable=protected-access
import asyncio
import datetime
import re
import time
from collections.abc import Collection
from collections.abc import Iterator
from itertools import repeat
from typing import Any
from unittest.mock import AsyncMock
from unittest.mock import MagicMock
from unittest.mock import patch
from uuid import UUID
from uuid import uuid4

import pytest
from fastapi.encoders import jsonable_encoder
from fastramqpi.context import Context
from freezegun import freeze_time
from httpx import Response
from ldap3.core.exceptions import LDAPInvalidValueError
from more_itertools import flatten
from more_itertools import one
from pydantic import BaseModel
from pydantic import Field
from pydantic import parse_obj_as
from ramodels.mo._shared import MOBase
from ramodels.mo.details.address import Address
from ramodels.mo.details.engagement import Engagement
from ramodels.mo.details.it_system import ITUser
from ramodels.mo.employee import Employee
from ramodels.mo.organisation_unit import OrganisationUnit
from structlog.testing import capture_logs

from mo_ldap_import_export.autogenerated_graphql_client.class_create import (
    ClassCreateClassCreate,
)
from mo_ldap_import_export.autogenerated_graphql_client.client import GraphQLClient
from mo_ldap_import_export.autogenerated_graphql_client.read_addresses import (
    ReadAddressesAddresses,
)
from mo_ldap_import_export.autogenerated_graphql_client.read_class_uuid import (
    ReadClassUuidClasses,
)
from mo_ldap_import_export.autogenerated_graphql_client.read_class_uuid import (
    ReadClassUuidClassesObjects,
)
from mo_ldap_import_export.autogenerated_graphql_client.read_employee_uuid_by_cpr_number import (
    ReadEmployeeUuidByCprNumberEmployees,
)
from mo_ldap_import_export.autogenerated_graphql_client.read_employee_uuid_by_ituser_user_key import (
    ReadEmployeeUuidByItuserUserKeyItusers,
)
from mo_ldap_import_export.autogenerated_graphql_client.read_facet_uuid import (
    ReadFacetUuidFacets,
)
from mo_ldap_import_export.config import Settings
from mo_ldap_import_export.converters import get_or_create_engagement_type_uuid
from mo_ldap_import_export.converters import get_or_create_job_function_uuid
from mo_ldap_import_export.converters import load_mo_root_org_uuid
from mo_ldap_import_export.dataloaders import DN
from mo_ldap_import_export.dataloaders import DataLoader
from mo_ldap_import_export.dataloaders import LdapObject
from mo_ldap_import_export.dataloaders import Verb
from mo_ldap_import_export.dataloaders import extract_current_or_latest_validity
from mo_ldap_import_export.exceptions import AttributeNotFound
from mo_ldap_import_export.exceptions import DNNotFound
from mo_ldap_import_export.exceptions import MultipleObjectsReturnedException
from mo_ldap_import_export.exceptions import NoObjectsReturnedException
from mo_ldap_import_export.exceptions import ReadOnlyException
from mo_ldap_import_export.routes import load_all_current_it_users
from mo_ldap_import_export.routes import load_ldap_attribute_values
from mo_ldap_import_export.routes import load_ldap_objects
from mo_ldap_import_export.routes import load_ldap_populated_overview
from mo_ldap_import_export.types import CPRNumber
from mo_ldap_import_export.types import OrgUnitUUID
from mo_ldap_import_export.utils import extract_ou_from_dn
from tests.graphql_mocker import GraphQLMocker


def gen_ituser(user_key: str) -> ITUser:
    return ITUser(
        user_key=user_key, itsystem={"uuid": uuid4()}, validity={"from": "2020-01-01"}
    )


def gen_address(user_key: str) -> Address:
    return Address(
        user_key=user_key,
        validity={"from": "2020-01-01"},
        value=str(uuid4()),
        address_type={"uuid": uuid4()},
    )


def gen_engagement(user_key: str) -> Engagement:
    return Engagement(
        user_key=user_key,
        validity={"from": "2020-01-01"},
        org_unit={"uuid": uuid4()},
        person={"uuid": uuid4()},
        job_function={"uuid": uuid4()},
        engagement_type={"uuid": uuid4()},
    )


def gen_employee(user_key: str) -> Employee:
    return Employee(
        user_key=user_key,
    )


def gen_org_unit(user_key: str) -> OrganisationUnit:
    return OrganisationUnit.from_simplified_fields(
        user_key=user_key,
        name=user_key,
        org_unit_type_uuid=uuid4(),
        org_unit_level_uuid=uuid4(),
        from_date="2020-01-01",
        parent_uuid=uuid4(),
        uuid=uuid4(),
    )


@pytest.fixture()
def ldap_attributes() -> dict:
    return {
        "department": None,
        "name": "John",
        "employeeID": "0101011234",
        "postalAddress": "foo",
    }


@pytest.fixture
def cpr_field() -> str:
    return "employeeID"


@pytest.fixture
def ldap_connection(ldap_attributes: dict) -> Iterator[MagicMock]:
    """Fixture to construct a mock ldap_connection.

    Yields:
        A mock for ldap_connection.
    """

    with patch(
        "mo_ldap_import_export.dataloaders.get_ldap_attributes",
        return_value=ldap_attributes.keys(),
    ):
        ldap_connection = MagicMock()
        ldap_connection.compare.return_value = False
        yield ldap_connection


@pytest.fixture
def legacy_graphql_session() -> Iterator[AsyncMock]:
    yield AsyncMock()


@pytest.fixture
def legacy_model_client() -> Iterator[AsyncMock]:
    yield AsyncMock()


@pytest.fixture
def graphql_client() -> Iterator[AsyncMock]:
    yield AsyncMock()


@pytest.fixture
def settings(monkeypatch: pytest.MonkeyPatch):
    monkeypatch.setenv(
        "CONVERSION_MAPPING",
        '{"ldap_to_mo": {}, "mo_to_ldap": {}, "username_generator": {}}',
    )
    monkeypatch.setenv("CLIENT_ID", "foo")
    monkeypatch.setenv("CLIENT_SECRET", "bar")
    monkeypatch.setenv("LDAP_CONTROLLERS", '[{"host": "0.0.0.0"}]')
    monkeypatch.setenv("LDAP_DOMAIN", "LDAP")
    monkeypatch.setenv("LDAP_USER", "foo")
    monkeypatch.setenv("LDAP_PASSWORD", "bar")
    monkeypatch.setenv("LDAP_SEARCH_BASE", "DC=ad,DC=addev")
    monkeypatch.setenv("DEFAULT_ORG_UNIT_LEVEL", "foo")
    monkeypatch.setenv("DEFAULT_ORG_UNIT_TYPE", "foo")
    monkeypatch.setenv("LDAP_OUS_TO_WRITE_TO", '[""]')
    monkeypatch.setenv("FASTRAMQPI__AMQP__URL", "amqp://guest:guest@msg_broker:5672/")
    monkeypatch.setenv("INTERNAL_AMQP__URL", "amqp://guest:guest@msg_broker:5672/")

    return Settings()


@pytest.fixture
def converter() -> MagicMock:
    converter_mock = MagicMock()
    converter_mock.find_ldap_object_class.return_value = "user"
    converter_mock._export_to_ldap_ = MagicMock()
    converter_mock._export_to_ldap_.return_value = True
    return converter_mock


@pytest.fixture
def username_generator() -> MagicMock:
    return AsyncMock()


@pytest.fixture
def sync_tool() -> AsyncMock:
    sync_tool = AsyncMock()
    return sync_tool


@pytest.fixture
def context(
    ldap_connection: MagicMock,
    legacy_graphql_session: AsyncMock,
    legacy_model_client: AsyncMock,
    graphql_client: AsyncMock,
    settings: Settings,
    cpr_field: str,
    converter: MagicMock,
    sync_tool: AsyncMock,
    username_generator: MagicMock,
) -> Context:
    return {
        "legacy_graphql_session": legacy_graphql_session,
        "legacy_model_client": legacy_model_client,
        "graphql_client": graphql_client,
        "user_context": {
            "settings": settings,
            "ldap_connection": ldap_connection,
            "cpr_field": cpr_field,
            "converter": converter,
            "sync_tool": sync_tool,
            "username_generator": username_generator,
            "ldap_it_system_user_key": "Active Directory",
        },
    }


@pytest.fixture
def get_attribute_types() -> dict:
    attr1_mock = MagicMock()
    attr2_mock = MagicMock()
    attr1_mock.single_value = False
    attr2_mock.single_value = True
    attr1_mock.syntax = "1.3.6.1.4.1.1466.115.121.1.7"  # Boolean
    attr2_mock.syntax = "1.3.6.1.4.1.1466.115.121.1.27"  # Integer
    return {
        "attr1": attr1_mock,
        "attr2": attr2_mock,
        "department": MagicMock(),
        "name": MagicMock(),
        "employeeID": MagicMock(),
        "postalAddress": MagicMock(),
        "objectClass": MagicMock(),
    }


@pytest.fixture
def dataloader(context: Context, get_attribute_types: dict) -> DataLoader:
    """Fixture to construct a dataloaders object using fixture mocks.

    Yields:
        Dataloaders with mocked clients.
    """
    with patch(
        "mo_ldap_import_export.dataloaders.get_attribute_types",
        return_value=get_attribute_types,
    ):
        return DataLoader(context)


@pytest.fixture
def graphql_mock(dataloader, respx_mock) -> Iterator[GraphQLMocker]:
    dataloader.context["graphql_client"] = GraphQLClient("http://example.com/graphql")

    yield GraphQLMocker(respx_mock)


def mock_ldap_response(ldap_attributes: dict, dn: DN) -> dict[str, Collection[str]]:
    expected_attributes = ldap_attributes.keys()
    inner_dict = ldap_attributes

    for attribute in expected_attributes:
        if attribute not in inner_dict.keys():
            inner_dict[attribute] = None

    response = {"dn": dn, "type": "searchResEntry", "attributes": inner_dict}

    return response


async def test_load_ldap_cpr_object(
    ldap_connection: MagicMock, dataloader: DataLoader, ldap_attributes: dict
) -> None:
    # Mock data
    dn = "CN=Nick Janssen,OU=Users,OU=Magenta,DC=ad,DC=addev"

    expected_result = LdapObject(dn=dn, **ldap_attributes)
    ldap_connection.get_response.return_value = (
        [mock_ldap_response(ldap_attributes, dn)],
        {"type": "test"},
    )

    output = one(
        await dataloader.load_ldap_cpr_object(CPRNumber("0101012002"), "Employee")
    )
    assert output == expected_result

    with pytest.raises(NoObjectsReturnedException):
        await dataloader.load_ldap_cpr_object("__invalid__", "Employee")  # type: ignore

    with pytest.raises(NoObjectsReturnedException):
        dataloader.user_context["cpr_field"] = None
        await dataloader.load_ldap_cpr_object(CPRNumber("0101012002"), "Employee")


async def test_load_ldap_objects(
    ldap_connection: MagicMock, dataloader: DataLoader, ldap_attributes: dict
) -> None:
    dn = "CN=Nick Janssen,OU=Users,OU=Magenta,DC=ad,DC=addev"
    expected_result = [LdapObject(dn=dn, **ldap_attributes)] * 2
    ldap_connection.get_response.return_value = (
        [mock_ldap_response(ldap_attributes, dn)] * 2,
        {"type": "test", "description": "success"},
    )

    output = await load_ldap_objects(dataloader, "Employee")

    assert output == expected_result


async def test_load_ldap_OUs(ldap_connection: MagicMock, dataloader: DataLoader):
    group_dn1 = "OU=Users,OU=Magenta,DC=ad,DC=addev"
    group_dn2 = "OU=Groups,OU=Magenta,DC=ad,DC=addev"
    ou1 = extract_ou_from_dn(group_dn1)
    ou2 = extract_ou_from_dn(group_dn2)
    user_dn = "CN=Nick Janssen,OU=Users,OU=Magenta,DC=ad,DC=addev"

    first_response = [
        mock_ldap_response({}, group_dn1),
        mock_ldap_response({}, group_dn2),
    ]

    second_response = [mock_ldap_response({}, user_dn)]
    third_response: list = []

    responses = iter(
        [
            first_response,
            second_response,
            third_response,
        ]
    )

    def set_new_result(*args, **kwargs) -> None:
        ldap_connection.get_response.return_value = (
            next(responses),
            {"type": "test", "description": "success"},
        )

    ldap_connection.search.side_effect = set_new_result

    output = await dataloader.load_ldap_OUs(None)

    assert ou1 in output
    assert ou2 in output
    assert output[ou1]["empty"] is False
    assert output[ou2]["empty"] is True


async def test_modify_ldap_employee(
    ldap_connection: MagicMock,
    dataloader: DataLoader,
    ldap_attributes: dict,
) -> None:
    employee = LdapObject(
        dn="CN=Nick Janssen,OU=Users,OU=Magenta,DC=ad,DC=addev",
        **ldap_attributes,
    )

    bad_response = {
        "result": 67,
        "description": "notAllowedOnRDN",
        "dn": "",
        "message": (
            "000020B1: UpdErr: DSID-030F1357,"
            " problem 6004 (CANT_ON_RDN), data 0\n\x00"
        ),
        "referrals": None,
        "type": "modifyResponse",
    }
    good_response = {
        "result": 0,
        "description": "success",
        "dn": "",
        "message": "",
        "referrals": None,
        "type": "modifyResponse",
    }

    # LDAP does not allow one to change the 'name' attribute and throws a bad response
    not_allowed_on_RDN = {"name"}
    parameters_to_upload = set(employee.dict().keys())
    parameters_to_upload.discard("dn")
    parameters_to_upload.discard("cpr")

    allowed_parameters_to_upload = parameters_to_upload - not_allowed_on_RDN
    disallowed_parameters_to_upload = (
        parameters_to_upload - allowed_parameters_to_upload
    )

    num_allowed_parameters = len(allowed_parameters_to_upload)
    num_disallowed_parameters = len(disallowed_parameters_to_upload)

    expected = [good_response] * num_allowed_parameters + [
        bad_response
    ] * num_disallowed_parameters
    compare_result = {"type": "test", "description": "compareFalse"}
    results = flatten(zip(repeat(compare_result), expected))

    def set_new_result(*args, **kwargs) -> None:
        ldap_connection.get_response.return_value = [], next(results)

    # Every time a modification is performed, point to the next page.
    ldap_connection.modify.side_effect = set_new_result
    ldap_connection.compare.side_effect = set_new_result

    dataloader.ldap_connection.get_response.return_value = (
        [],
        {"type": "test", "description": "compareFalse"},
    )
    # Get result from dataloader
    with patch(
        "mo_ldap_import_export.dataloaders.DataLoader.load_ldap_cpr_object",
        return_value=employee,
    ):
        output = await dataloader.modify_ldap_object(employee, "user")

    assert output == expected


async def test_append_data_to_ldap_object(
    ldap_connection: MagicMock,
    dataloader: DataLoader,
    ldap_attributes: dict,
    cpr_field: str,
):
    dataloader.ldap_connection.get_response.return_value = (
        [],
        {"type": "test", "description": "compareTrue"},
    )

    address = LdapObject(
        dn="CN=Nick Janssen,OU=Users,OU=Magenta,DC=ad,DC=addev",
        postalAddress="foo",
        **{cpr_field: "123"},
    )

    dataloader.single_value = {"postalAddress": False, cpr_field: True}

    await dataloader.modify_ldap_object(address, "user")

    changes = {"postalAddress": [("MODIFY_ADD", "foo")]}
    dn = address.dn
    assert ldap_connection.modify.called_once_with(dn, changes)


async def test_delete_data_from_ldap_object(
    ldap_connection: MagicMock,
    dataloader: DataLoader,
    ldap_attributes: dict,
    cpr_field: str,
):
    dataloader.ldap_connection.get_response.return_value = (
        [],
        {"type": "test", "description": "compareTrue"},
    )

    address = LdapObject(
        dn="CN=Nick Janssen,OU=Users,OU=Magenta,DC=ad,DC=addev",
        postalAddress="foo",
        sharedValue="bar",
        **{cpr_field: "123"},
    )

    dataloader.single_value = {"postalAddress": False, cpr_field: True}

    # Note: 'sharedValue' won't be deleted because it is shared with another ldap object
    dataloader._mo_to_ldap_attributes = [
        "postalAddress",
        cpr_field,
        cpr_field,
        "sharedValue",
        "sharedValue",
    ]

    await dataloader.modify_ldap_object(address, "user", delete=True)

    changes = {"postalAddress": [("MODIFY_DELETE", "foo")]}
    dn = address.dn
    assert ldap_connection.modify.called_once_with(dn, changes)


async def test_upload_ldap_object_invalid_value(
    ldap_connection: MagicMock,
    dataloader: DataLoader,
    cpr_field: str,
) -> None:
    dataloader.ldap_connection.get_response.return_value = (
        [],
        {"type": "test", "description": "compareFalse"},
    )

    ldap_object = LdapObject(
        dn="CN=Nick Janssen,OU=Users,OU=Magenta,DC=ad,DC=addev",
        postalAddress="foo",
        **{cpr_field: "123"},
    )

    ldap_connection.modify.side_effect = LDAPInvalidValueError("Invalid value")

    with capture_logs() as cap_logs:
        await dataloader.modify_ldap_object(ldap_object, "user")

        warnings = [w for w in cap_logs if w["log_level"] == "warning"]
        last_warning_message = str(warnings[-1]["event"])
        assert last_warning_message == "LDAPInvalidValueError exception"


async def test_modify_ldap_object_but_export_equals_false(
    dataloader: DataLoader, converter: MagicMock
):
    converter._export_to_ldap_.return_value = False
    ldap_object = LdapObject(
        dn="CN=Nick Janssen,OU=Users,OU=Magenta,DC=ad,DC=addev",
        postalAddress="foo",
    )

    with capture_logs() as cap_logs:
        await dataloader.modify_ldap_object(ldap_object, "")

        messages = [w for w in cap_logs if w["log_level"] == "info"]
        assert re.match(
            ".*_export_to_ldap_ == False",
            str(messages[-1]["event"]),
        )


async def test_load_mo_employee(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    cpr_no = "1407711900"
    uuid = uuid4()

    employee = {
        "uuid": uuid,
        "cpr_no": cpr_no,
        "givenname": "first_name",
        "surname": "last_name",
        "nickname_givenname": None,
        "nickname_surname": None,
        "validity": {"to": None},
    }

    route = graphql_mock.query("read_employees")
    route.result = {"employees": {"objects": [{"validities": [employee]}]}}

    employee.pop("validity")
    expected_result = Employee(**employee)

    output = await dataloader.load_mo_employee(uuid)
    assert output == expected_result
    assert route.called


async def test_load_mo_employee_no_objects(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    uuid = uuid4()

    route = graphql_mock.query("read_employees")
    route.result = {"employees": {"objects": []}}

    result = await dataloader.load_mo_employee(uuid)
    assert result is None
    assert route.called


async def test_load_mo_employee_no_validities(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    uuid = uuid4()

    route = graphql_mock.query("read_employees")
    route.result = {"employees": {"objects": [{"validities": []}]}}

    result = await dataloader.load_mo_employee(uuid)
    assert result is None
    assert route.called


@pytest.mark.parametrize(
    "input_value,return_value",
    [
        (gen_ituser("1"), "1"),
        (gen_ituser("2"), "2"),
        (gen_ituser("3"), "3"),
    ],
)
async def test_upload_mo_employee(
    legacy_model_client: AsyncMock,
    dataloader: DataLoader,
    input_value: ITUser,
    return_value: str | None,
) -> None:
    """Test that upload_mo_employee works as expected."""
    legacy_model_client.upload.return_value = return_value

    result = await dataloader.create([input_value])  # type: ignore
    assert result == [return_value]
    legacy_model_client.upload.assert_called_with([input_value])


async def test_make_overview_entry(dataloader: DataLoader):
    attributes = ["attr1", "attr2", "unknownattr"]
    superiors = ["sup1", "sup2"]
    entry = dataloader.make_overview_entry(attributes, superiors)

    assert list(entry["attributes"].keys()) == ["attr1", "attr2"]
    assert entry["superiors"] == superiors

    assert entry["attributes"]["attr1"]["single_value"] is False
    assert entry["attributes"]["attr2"]["single_value"] is True

    assert entry["attributes"]["attr1"]["field_type"] == "Boolean"
    assert entry["attributes"]["attr2"]["field_type"] == "Integer"


async def test_get_overview(dataloader: DataLoader):
    schema_mock = MagicMock()
    schema_mock.object_classes = {"object1": "foo"}

    with patch(
        "mo_ldap_import_export.dataloaders.get_ldap_schema",
        return_value=schema_mock,
    ), patch(
        "mo_ldap_import_export.dataloaders.get_ldap_attributes",
        return_value=["attr1", "attr2"],
    ), patch(
        "mo_ldap_import_export.dataloaders.get_ldap_superiors",
        return_value=["sup1", "sup2"],
    ):
        output = dataloader.load_ldap_overview()

    assert list(output["object1"]["attributes"].keys()) == ["attr1", "attr2"]
    assert output["object1"]["superiors"] == ["sup1", "sup2"]
    assert output["object1"]["attributes"]["attr1"]["single_value"] is False
    assert output["object1"]["attributes"]["attr2"]["single_value"] is True

    assert output["object1"]["attributes"]["attr1"]["field_type"] == "Boolean"
    assert output["object1"]["attributes"]["attr2"]["field_type"] == "Integer"


async def test_get_populated_overview(dataloader: DataLoader):
    overview = {
        "user": {"attributes": ["attr1", "attr2"], "superiors": ["sup1", "sup2"]}
    }

    responses = [
        {
            "attributes": {
                "attr1": "foo",  # We expect this attribute in the output
                "attr2": None,  # But not this one
                "objectClass": ["top", "person", "user"],
            }
        },
        {
            "attributes": {
                "attr1": "foo",
                "attr2": "bar",  # We still do not expect this one; wrong object class
                "objectClass": ["top", "person", "user", "computer"],
            }
        },
    ]

    dataloader.load_ldap_overview = lambda: overview  # type: ignore

    with patch(
        "mo_ldap_import_export.routes.paged_search",
        return_value=responses,
    ):
        output = await load_ldap_populated_overview(dataloader)

    assert sorted(list(output["user"]["attributes"].keys())) == sorted(
        ["attr1", "objectClass"]
    )
    assert output["user"]["superiors"] == ["sup1", "sup2"]
    assert output["user"]["attributes"]["attr1"]["single_value"] is False


@pytest.mark.parametrize(
    "objects",
    [
        # No objects returned
        [],
        # Object returned, but no validities
        [{"validities": []}],
    ],
)
async def test_load_mo_address_not_found(
    dataloader: DataLoader, graphql_mock: GraphQLMocker, objects: list[dict]
) -> None:
    route = graphql_mock.query("read_addresses")
    route.result = {"addresses": {"objects": objects}}

    result = await dataloader.load_mo_address(uuid4())
    assert result is None

    assert route.called


async def test_load_mo_address(dataloader: DataLoader) -> None:
    uuid = uuid4()

    address_dict: dict = {
        "value": "foo@bar.dk",
        "uuid": uuid,
        "address_type": {"uuid": uuid},
        "validity": {"from": "2021-01-01 01:00", "to": None},
        "person": {"uuid": uuid},
        "org_unit": {"uuid": uuid},
        "visibility": {"uuid": uuid},
        "engagement": {"uuid": uuid},
    }

    # Note that 'Address' requires 'person' to be a dict
    expected_result = Address(**address_dict.copy())

    # While graphQL returns it as a list with length 1
    address_dict["person"] = [{"cpr_no": "0101012002"}]
    address_dict["address_type"]["user_key"] = "address"
    address_dict["value2"] = None
    address_dict["visibility_uuid"] = uuid
    address_dict["employee_uuid"] = uuid
    address_dict["org_unit_uuid"] = uuid
    address_dict["engagement_uuid"] = uuid

    dataloader.graphql_client.read_addresses.return_value = parse_obj_as(  # type: ignore
        ReadAddressesAddresses,
        {
            "objects": [
                {"validities": [address_dict]},
            ]
        },
    )

    output = await dataloader.load_mo_address(uuid)
    assert output == expected_result


async def test_load_mo_employee_addresses(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    address1_uuid = uuid4()
    address2_uuid = uuid4()

    route = graphql_mock.query("read_employee_addresses")
    route.result = {
        "addresses": {
            "objects": [
                {"uuid": address1_uuid},
                {"uuid": address2_uuid},
            ]
        }
    }

    load_mo_address = AsyncMock()
    dataloader.load_mo_address = load_mo_address  # type: ignore

    employee_uuid = uuid4()
    address_type_uuid = uuid4()
    await dataloader.load_mo_employee_addresses(employee_uuid, address_type_uuid)

    assert route.called
    load_mo_address.assert_any_call(address1_uuid)
    load_mo_address.assert_any_call(address2_uuid)


async def test_load_mo_employee_addresses_not_found(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    route = graphql_mock.query("read_employee_addresses")
    route.result = {"addresses": {"objects": []}}

    employee_uuid = uuid4()
    address_type_uuid = uuid4()
    result = await dataloader.load_mo_employee_addresses(
        employee_uuid, address_type_uuid
    )
    assert result == []

    assert route.called


def mock_read_employee_uuid_by_cpr_number(
    dataloader: DataLoader, values: list[UUID]
) -> None:
    dataloader.graphql_client.read_employee_uuid_by_cpr_number.return_value = (  # type: ignore
        parse_obj_as(
            ReadEmployeeUuidByCprNumberEmployees,
            {"objects": [{"uuid": uuid} for uuid in values]},
        )
    )


def mock_read_employee_uuid_by_ituser(
    dataloader: DataLoader, values: list[UUID]
) -> None:
    dataloader.graphql_client.read_employee_uuid_by_ituser_user_key.return_value = (  # type: ignore
        parse_obj_as(
            ReadEmployeeUuidByItuserUserKeyItusers,
            {"objects": [{"current": {"employee_uuid": uuid}} for uuid in values]},
        )
    )


async def test_find_mo_employee_uuid_by_cpr_number(dataloader: DataLoader):
    uuid = uuid4()
    dataloader.user_context["cpr_field"] = "employeeID"

    with patch(
        "mo_ldap_import_export.dataloaders.DataLoader.load_ldap_object",
        return_value=LdapObject(
            dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
        ),
    ):
        mock_read_employee_uuid_by_cpr_number(dataloader, [uuid])
        mock_read_employee_uuid_by_ituser(dataloader, [])
        output = await dataloader.find_mo_employee_uuid("CN=foo")
        assert output == uuid


async def test_find_mo_employee_uuid_by_ituser(dataloader: DataLoader):
    uuid = uuid4()
    dataloader.user_context["cpr_field"] = "employeeID"

    with patch(
        "mo_ldap_import_export.dataloaders.DataLoader.load_ldap_object",
        return_value=LdapObject(dn="CN=foo", employeeID="Ja", objectGUID=str(uuid4())),
    ):
        mock_read_employee_uuid_by_cpr_number(dataloader, [])
        mock_read_employee_uuid_by_ituser(dataloader, [uuid])
        output = await dataloader.find_mo_employee_uuid("CN=foo")
        assert output == uuid


async def test_find_mo_employee_uuid_fallback_ituser(dataloader: DataLoader):
    uuid1 = uuid4()
    uuid2 = uuid4()
    dataloader.user_context["cpr_field"] = None

    with patch(
        "mo_ldap_import_export.dataloaders.DataLoader.load_ldap_object",
        return_value=LdapObject(
            dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
        ),
    ):
        # There is a CPR match, but it is not configured, so we get the ITUser match
        mock_read_employee_uuid_by_cpr_number(dataloader, [uuid1])
        mock_read_employee_uuid_by_ituser(dataloader, [uuid2])
        output = await dataloader.find_mo_employee_uuid("CN=foo")
        assert output == uuid2


async def test_find_mo_employee_uuid_not_found(dataloader: DataLoader):
    with patch(
        "mo_ldap_import_export.dataloaders.DataLoader.load_ldap_object",
        return_value=LdapObject(
            dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
        ),
    ):
        mock_read_employee_uuid_by_cpr_number(dataloader, [])
        mock_read_employee_uuid_by_ituser(dataloader, [])
        output = await dataloader.find_mo_employee_uuid("CN=foo")
        assert output is None


async def test_find_mo_employee_uuid_cpr_number_multiple_matches(
    dataloader: DataLoader,
):
    with patch(
        "mo_ldap_import_export.dataloaders.DataLoader.load_ldap_object",
        return_value=LdapObject(
            dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
        ),
    ):
        mock_read_employee_uuid_by_cpr_number(dataloader, [uuid4(), uuid4()])
        mock_read_employee_uuid_by_ituser(dataloader, [])
        with pytest.raises(MultipleObjectsReturnedException):
            await dataloader.find_mo_employee_uuid("CN=foo")


async def test_find_mo_employee_uuid_ituser_multiple_matches(dataloader: DataLoader):
    with patch(
        "mo_ldap_import_export.dataloaders.DataLoader.load_ldap_object",
        return_value=LdapObject(
            dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
        ),
    ):
        mock_read_employee_uuid_by_cpr_number(dataloader, [])
        mock_read_employee_uuid_by_ituser(dataloader, [uuid4(), uuid4()])
        with pytest.raises(MultipleObjectsReturnedException):
            await dataloader.find_mo_employee_uuid("CN=foo")


async def test_find_mo_employee_uuid_multiple_matches(dataloader: DataLoader):
    uuid1 = uuid4()
    uuid2 = uuid4()
    dataloader.user_context["cpr_field"] = "employeeID"

    with patch(
        "mo_ldap_import_export.dataloaders.DataLoader.load_ldap_object",
        return_value=LdapObject(
            dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
        ),
    ):
        # We never actually check ituser, due to early return
        mock_read_employee_uuid_by_cpr_number(dataloader, [uuid1])
        mock_read_employee_uuid_by_ituser(dataloader, [uuid2])
        output = await dataloader.find_mo_employee_uuid("CN=foo")
        assert output == uuid1


async def test_load_mo_employee_not_found(
    dataloader: DataLoader, legacy_graphql_session: AsyncMock
):
    legacy_graphql_session.execute.return_value = {"employees": {"objects": []}}

    uuid = uuid4()

    result = await dataloader.load_mo_employee(uuid)
    assert result is None


async def test_load_mo_it_user(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    uuid1 = uuid4()
    uuid2 = uuid4()

    route = graphql_mock.query("read_itusers")
    route.result = {
        "itusers": {
            "objects": [
                {
                    "validities": [
                        {
                            "user_key": "foo",
                            "validity": {"from": "2021-01-01T00:00:00", "to": None},
                            "employee_uuid": uuid1,
                            "itsystem_uuid": uuid2,
                            "engagement_uuid": uuid1,
                        }
                    ]
                }
            ]
        }
    }

    output = await dataloader.load_mo_it_user(uuid4())
    assert output is not None
    assert output.user_key == "foo"
    assert output.itsystem.uuid == uuid2
    assert output.person.uuid == uuid1  # type: ignore
    assert output.engagement.uuid == uuid1  # type: ignore
    assert output.validity.from_date.strftime("%Y-%m-%d") == "2021-01-01"

    assert route.called


async def test_load_mo_engagement(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    route = graphql_mock.query("read_engagements")
    route.result = {
        "engagements": {
            "objects": [
                {
                    "validities": [
                        {
                            "user_key": "foo",
                            "validity": {"from": "2021-01-01T00:00:00", "to": None},
                            "extension_1": "extra info",
                            "extension_2": "more extra info",
                            "extension_3": None,
                            "extension_4": None,
                            "extension_5": None,
                            "extension_6": None,
                            "extension_7": None,
                            "extension_8": None,
                            "extension_9": None,
                            "extension_10": None,
                            "leave_uuid": uuid4(),
                            "primary_uuid": uuid4(),
                            "job_function_uuid": uuid4(),
                            "org_unit_uuid": uuid4(),
                            "engagement_type_uuid": uuid4(),
                            "employee_uuid": uuid4(),
                        }
                    ]
                }
            ]
        }
    }

    output = await dataloader.load_mo_engagement(uuid4())
    assert output.user_key == "foo"
    assert output.validity.from_date.strftime("%Y-%m-%d") == "2021-01-01"
    assert output.extension_1 == "extra info"
    assert output.extension_2 == "more extra info"

    assert route.called


async def test_load_mo_engagement_missing(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    route = graphql_mock.query("read_engagements")
    route.result = {"engagements": {"objects": []}}

    with pytest.raises(NoObjectsReturnedException):
        await dataloader.load_mo_engagement(uuid4())

    assert route.called


@pytest.mark.parametrize(
    "objects",
    [
        # No objects returned
        [],
        # Object returned, but no validities
        [{"validities": []}],
    ],
)
async def test_load_mo_it_user_not_found(
    dataloader: DataLoader, graphql_mock: GraphQLMocker, objects: list[dict]
) -> None:
    route = graphql_mock.query("read_itusers")
    route.result = {"itusers": {"objects": objects}}

    result = await dataloader.load_mo_it_user(uuid4())
    assert result is None

    assert route.called


async def test_load_mo_employee_it_users(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    ituser_uuid = uuid4()

    route = graphql_mock.query("read_ituser_by_employee_and_itsystem_uuid")
    route.result = {"itusers": {"objects": [{"uuid": ituser_uuid}]}}

    load_mo_it_user = AsyncMock()
    dataloader.load_mo_it_user = load_mo_it_user  # type: ignore

    employee_uuid = uuid4()
    it_system_uuid = uuid4()
    await dataloader.load_mo_employee_it_users(employee_uuid, it_system_uuid)

    assert route.called
    load_mo_it_user.assert_called_once_with(ituser_uuid)


async def test_load_mo_employee_it_users_not_found(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    route = graphql_mock.query("read_ituser_by_employee_and_itsystem_uuid")
    route.result = {"itusers": {"objects": []}}

    employee_uuid = uuid4()
    it_system_uuid = uuid4()
    result = await dataloader.load_mo_employee_it_users(employee_uuid, it_system_uuid)
    assert result == []

    assert route.called


async def test_load_mo_org_unit_addresses(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
):
    address_uuid1 = uuid4()
    address_uuid2 = uuid4()

    route = graphql_mock.query("read_org_unit_addresses")
    route.result = {
        "addresses": {"objects": [{"uuid": address_uuid1}, {"uuid": address_uuid2}]}
    }

    load_mo_address = AsyncMock()
    dataloader.load_mo_address = load_mo_address  # type: ignore

    org_unit_uuid = uuid4()
    address_type_uuid = uuid4()
    await dataloader.load_mo_org_unit_addresses(
        OrgUnitUUID(org_unit_uuid), address_type_uuid
    )

    assert route.called
    load_mo_address.assert_any_call(address_uuid1)
    load_mo_address.assert_any_call(address_uuid2)


async def test_load_mo_org_unit_addresses_not_found(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    route = graphql_mock.query("read_org_unit_addresses")
    route.result = {"addresses": {"objects": []}}

    employee_uuid = uuid4()
    address_type_uuid = uuid4()
    result = await dataloader.load_mo_org_unit_addresses(
        OrgUnitUUID(employee_uuid), address_type_uuid
    )
    assert result == []

    assert route.called


async def test_load_mo_employee_engagements(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    uuid1 = uuid4()

    route = graphql_mock.query("read_engagements_by_employee_uuid")
    route.result = {
        "engagements": {
            "objects": [
                {
                    "current": {
                        "uuid": uuid1,
                        "validity": {"from": "2020-01-01T00:00:00"},
                    }
                }
            ]
        }
    }

    load_mo_engagement = AsyncMock()
    dataloader.load_mo_engagement = load_mo_engagement  # type: ignore

    employee_uuid = uuid4()
    await dataloader.load_mo_employee_engagements(employee_uuid)

    load_mo_engagement.assert_called_once_with(uuid1)
    assert route.called


@pytest.mark.parametrize(
    "engagement_uuids,results,expected",
    [
        # Zero UUIDs requested
        # ------------------
        # No uuids to lookup, should be early returned
        ([], [], []),
        # One UUID requested
        # ------------------
        # Base case, one reply (ours), primary and non-primary respectively
        (
            ["085bef5d-f435-4fe1-89d6-3d0f6b72d8e8"],
            [
                {
                    "current": {
                        "is_primary": True,
                        "uuid": "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                    }
                }
            ],
            [True],
        ),
        (
            ["085bef5d-f435-4fe1-89d6-3d0f6b72d8e8"],
            [
                {
                    "current": {
                        "is_primary": False,
                        "uuid": "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                    }
                }
            ],
            [False],
        ),
        # No results at all
        (["085bef5d-f435-4fe1-89d6-3d0f6b72d8e8"], [], [False]),
        # No current results
        (["085bef5d-f435-4fe1-89d6-3d0f6b72d8e8"], [{"current": None}], [False]),
        # Multiple non-current results
        (
            ["085bef5d-f435-4fe1-89d6-3d0f6b72d8e8"],
            [{"current": None}, {"current": None}],
            [False],
        ),
        # Multiple unrelated results
        (
            ["085bef5d-f435-4fe1-89d6-3d0f6b72d8e8"],
            [
                {"current": {"is_primary": True, "uuid": uuid4()}},
                {"current": {"is_primary": True, "uuid": uuid4()}},
            ],
            [False],
        ),
        # Multiple UUIDs requested
        # ------------------------
        # Base case, one reply (ours), primary and non-primary respectively
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [
                {
                    "current": {
                        "is_primary": True,
                        "uuid": "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                    }
                },
                {
                    "current": {
                        "is_primary": False,
                        "uuid": "ec641c22-0a5a-497e-acfb-a9be84dea48a",
                    }
                },
            ],
            [True, False],
        ),
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [
                {
                    "current": {
                        "is_primary": False,
                        "uuid": "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                    }
                },
                {
                    "current": {
                        "is_primary": True,
                        "uuid": "ec641c22-0a5a-497e-acfb-a9be84dea48a",
                    }
                },
            ],
            [False, True],
        ),
        # No results at all
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [],
            [False, False],
        ),
        # No current results
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [{"current": None}],
            [False, False],
        ),
        # Only one result
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [
                {
                    "current": {
                        "is_primary": True,
                        "uuid": "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                    }
                },
            ],
            [True, False],
        ),
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [
                {
                    "current": {
                        "is_primary": True,
                        "uuid": "ec641c22-0a5a-497e-acfb-a9be84dea48a",
                    }
                },
            ],
            [False, True],
        ),
        # Multiple non-current results
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [{"current": None}, {"current": None}],
            [False, False],
        ),
        # Multiple unrelated results
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [
                {"current": {"is_primary": True, "uuid": uuid4()}},
                {"current": {"is_primary": True, "uuid": uuid4()}},
            ],
            [False, False],
        ),
    ],
)
async def test_is_primaries(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
    engagement_uuids: list[str],
    results: list[dict[str, Any]] | None,
    expected: list[bool],
) -> None:
    is_primary_engagements_route = graphql_mock.query("read_is_primary_engagements")
    is_primary_engagements_route.result = {"engagements": {"objects": results}}

    primary = await dataloader.is_primaries(list(map(UUID, engagement_uuids)))
    assert primary == expected

    assert is_primary_engagements_route.called


async def test_shared_attribute(dataloader: DataLoader):
    converter = MagicMock()
    converter.mapping = {
        "mo_to_ldap": {
            "Employee": {"cpr_no": None, "name": None},
            "Address": {"cpr_no": None, "value": None},
        }
    }
    dataloader.user_context["converter"] = converter

    assert dataloader.shared_attribute("cpr_no") is True
    assert dataloader.shared_attribute("name") is False
    assert dataloader.shared_attribute("value") is False

    with pytest.raises(AttributeNotFound):
        dataloader.shared_attribute("non_existing_attribute")


async def test_modify_ldap(
    dataloader: DataLoader,
    sync_tool: AsyncMock,
    ldap_connection: MagicMock,
    monkeypatch: pytest.MonkeyPatch,
):
    def setup_mock(compares: bool = False):
        result = "compareTrue" if compares else "compareFalse"
        ldap_connection.get_response.return_value = (
            [],
            {"type": "test", "description": result},
        )

        def set_new_result(*args, **kwargs):
            ldap_connection.get_response.return_value = (
                [],
                {"type": "test", "description": "success"},
            )

        ldap_connection.modify.side_effect = set_new_result

    dn = "CN=foo"

    # Validate that empty lists are allowed
    setup_mock()
    await dataloader.modify_ldap("MODIFY_REPLACE", dn, "parameter_to_modify", [])
    ldap_connection.compare.assert_called_with(dn, "parameter_to_modify", "")

    # Simulate case where a value exists
    with capture_logs() as cap_logs:
        setup_mock(True)
        await dataloader.modify_ldap("MODIFY_REPLACE", dn, "parameter_to_modify", [])
        messages = [w["event"] for w in cap_logs]
        assert messages == ["Attribute value already exists"]

    # DELETE statments should still be executed, even if a value exists
    setup_mock()
    response = await dataloader.modify_ldap(
        "MODIFY_DELETE", dn, "parameter_to_modify", "foo"
    )
    assert response == {"description": "success", "type": "test"}

    monkeypatch.setenv("LDAP_READ_ONLY", "true")
    dataloader.user_context["settings"] = Settings()
    with pytest.raises(ReadOnlyException) as exc:
        setup_mock()
        await dataloader.modify_ldap("MODIFY_REPLACE", dn, "parameter_to_modify", [])
    assert "LDAP connection is read-only" in str(exc.value)


async def test_modify_ldap_ou_not_in_ous_to_write_to(
    dataloader: DataLoader,
    sync_tool: AsyncMock,
    ldap_connection: MagicMock,
):
    dataloader.ou_in_ous_to_write_to = MagicMock()  # type: ignore
    dataloader.ou_in_ous_to_write_to.return_value = False

    assert (
        await dataloader.modify_ldap("MODIFY_ADD", "CN=foo", "attribute", "value")
        is None
    )  # type: ignore


async def test_get_ldap_it_system_uuid(
    graphql_mock: GraphQLMocker,
    dataloader: DataLoader,
) -> None:
    uuid = uuid4()
    route = graphql_mock.query("read_itsystem_uuid")
    route.result = {"itsystems": {"objects": [{"uuid": uuid}]}}

    assert await dataloader.get_ldap_it_system_uuid() == str(uuid)
    assert route.called

    route.reset()
    route.result = {"itsystems": {"objects": []}}
    assert await dataloader.get_ldap_it_system_uuid() is None
    assert route.called


async def test_find_mo_employee_dn(dataloader: MagicMock) -> None:
    employee_uuid = uuid4()

    dataloader.find_mo_employee_dn_by_itsystem = AsyncMock()
    dataloader.find_mo_employee_dn_by_itsystem.return_value = set()

    dataloader.find_mo_employee_dn_by_cpr_number = AsyncMock()
    dataloader.find_mo_employee_dn_by_cpr_number.return_value = set()

    with capture_logs() as cap_logs:
        result = await dataloader.find_mo_employee_dn(employee_uuid)
        assert result == set()
    log_events = [log["event"] for log in cap_logs]
    assert log_events == [
        "Attempting to find DNs",
        "Unable to find DNs for MO employee",
    ]

    dataloader.find_mo_employee_dn_by_itsystem.return_value = {"A", "B"}
    dataloader.find_mo_employee_dn_by_cpr_number.return_value = {"C", "D"}

    with capture_logs() as cap_logs:
        result = await dataloader.find_mo_employee_dn(employee_uuid)
        assert result == {"A", "B", "C", "D"}
    log_events = [log["event"] for log in cap_logs]
    assert log_events == ["Attempting to find DNs"]


async def test_make_mo_employee_dn_no_user(
    graphql_mock: GraphQLMocker, dataloader: MagicMock
) -> None:
    employee_uuid = uuid4()

    route = graphql_mock.query("read_employees")
    route.result = {"employees": {"objects": []}}

    with pytest.raises(NoObjectsReturnedException) as exc_info:
        await dataloader.make_mo_employee_dn(employee_uuid)
    assert f"Unable to lookup employee: {employee_uuid}" in str(exc_info.value)

    assert route.called


async def test_make_mo_employee_dn_no_correlation(dataloader: MagicMock) -> None:
    employee_uuid = uuid4()

    employee_object = MagicMock()
    employee_object.cpr_no = None
    employee_object.uuid = employee_uuid

    dataloader.load_mo_employee = AsyncMock()
    dataloader.load_mo_employee.return_value = employee_object

    dataloader.get_ldap_it_system_uuid = AsyncMock()
    dataloader.get_ldap_it_system_uuid.return_value = None

    with pytest.raises(DNNotFound) as exc_info:
        await dataloader.make_mo_employee_dn(employee_uuid)
    assert "Unable to generate DN, no correlation key available" in str(exc_info.value)


async def test_make_mo_employee_dn_no_itsystem(dataloader: MagicMock) -> None:
    employee_uuid = uuid4()

    employee_object = MagicMock()
    employee_object.cpr_no = "0101700000"
    employee_object.uuid = employee_uuid

    dataloader.load_mo_employee = AsyncMock()
    dataloader.load_mo_employee.return_value = employee_object

    dataloader.get_ldap_it_system_uuid = AsyncMock()
    dataloader.get_ldap_it_system_uuid.return_value = None

    dn = "CN=foo"
    username_generator = AsyncMock()
    username_generator.generate_dn.return_value = dn

    dataloader.user_context["username_generator"] = username_generator

    amqp_exchange_name = "amqp_exchange_name"
    dataloader.sync_tool.amqpsystem.exchange_name = amqp_exchange_name

    with capture_logs() as cap_logs:
        result = await dataloader.make_mo_employee_dn(employee_uuid)
        assert result == dn
    log_events = [log["event"] for log in cap_logs]
    assert log_events == ["Generating DN for user"]

    dataloader.sync_tool.import_single_user.assert_called_once_with(
        dn, manual_import=True
    )
    dataloader.graphql_client.employee_refresh.assert_called_once_with(
        amqp_exchange_name, [employee_uuid]
    )


async def test_make_mo_employee_dn_no_cpr(dataloader: MagicMock) -> None:
    employee_uuid = uuid4()

    employee_object = MagicMock()
    employee_object.cpr_no = None
    employee_object.uuid = employee_uuid

    dataloader.load_mo_employee = AsyncMock()
    dataloader.load_mo_employee.return_value = employee_object

    itsystem_uuid = uuid4()
    dataloader.get_ldap_it_system_uuid = AsyncMock()
    dataloader.get_ldap_it_system_uuid.return_value = str(itsystem_uuid)

    dn = "CN=foo"
    username_generator = AsyncMock()
    username_generator.generate_dn.return_value = dn

    dataloader.user_context["username_generator"] = username_generator

    ldap_uuid = uuid4()
    dataloader.get_ldap_unique_ldap_uuid = AsyncMock()
    dataloader.get_ldap_unique_ldap_uuid.return_value = ldap_uuid

    amqp_exchange_name = "amqp_exchange_name"
    dataloader.sync_tool.amqpsystem.exchange_name = amqp_exchange_name

    dataloader.create_ituser = AsyncMock()

    with capture_logs() as cap_logs:
        result = await dataloader.make_mo_employee_dn(employee_uuid)
        assert result == dn
    log_events = [log["event"] for log in cap_logs]
    assert log_events == [
        "Generating DN for user",
        "No ITUser found, creating one to correlate with DN",
        "LDAP UUID found for DN",
    ]

    dataloader.create_ituser.assert_called_once()
    dataloader.sync_tool.import_single_user.assert_called_once_with(
        dn, manual_import=True
    )
    dataloader.graphql_client.employee_refresh.assert_called_once_with(
        amqp_exchange_name, [employee_uuid]
    )


def test_extract_unique_objectGUIDs(dataloader: DataLoader):
    ad_it_user_1 = ITUser.from_simplified_fields(
        str(uuid4()),
        uuid4(),
        datetime.datetime.today().strftime("%Y-%m-%d"),
        person_uuid=uuid4(),
    )
    ad_it_user_2 = ITUser.from_simplified_fields(
        str(uuid4()),
        uuid4(),
        datetime.datetime.today().strftime("%Y-%m-%d"),
        person_uuid=uuid4(),
    )
    ad_it_user_3 = ITUser.from_simplified_fields(
        "not_an_uuid",
        uuid4(),
        datetime.datetime.today().strftime("%Y-%m-%d"),
        person_uuid=uuid4(),
    )

    objectGUIDs = dataloader.extract_unique_ldap_uuids(
        [ad_it_user_1, ad_it_user_2, ad_it_user_3]
    )

    assert UUID(ad_it_user_1.user_key) in objectGUIDs
    assert UUID(ad_it_user_2.user_key) in objectGUIDs
    assert len(objectGUIDs) == 2


@pytest.mark.parametrize(
    "ldap_dns,expected",
    [
        ([], set()),
        (["CN=foo"], {"CN=foo"}),
        (["CN=foo", "CN=foo"], {"CN=foo"}),
        (["CN=foo", "CN=bar"], {"CN=foo", "CN=bar"}),
        (["CN=foo", "CN=bar", "CN=bar"], {"CN=foo", "CN=bar"}),
        (["CN=foo", "CN=bar", "CN=baz"], {"CN=foo", "CN=bar", "CN=baz"}),
    ],
)
async def test_convert_ldap_uuids_to_dns(
    dataloader: DataLoader,
    ldap_dns: list[str],
    expected: set[str],
) -> None:
    dataloader.get_ldap_dn = AsyncMock()  # type: ignore
    dataloader.get_ldap_dn.side_effect = ldap_dns

    dns = await dataloader.convert_ldap_uuids_to_dns({uuid4() for _ in ldap_dns})
    assert dns == expected


async def test_convert_ldap_uuids_to_dns_exception(dataloader: DataLoader) -> None:
    dataloader.get_ldap_dn = AsyncMock()  # type: ignore
    dataloader.get_ldap_dn.side_effect = ["CN=foo", ValueError("BOOM")]

    with pytest.raises(ExceptionGroup) as exc_info:
        await dataloader.convert_ldap_uuids_to_dns({uuid4(), uuid4()})
    assert "Exceptions during UUID2DN translation" in str(exc_info.value)
    assert len(exc_info.value.exceptions) == 1

    dataloader.get_ldap_dn.side_effect = [ValueError("BANG"), ValueError("BOOM")]

    with pytest.raises(ExceptionGroup) as exc_info:
        await dataloader.convert_ldap_uuids_to_dns({uuid4(), uuid4()})
    assert "Exceptions during UUID2DN translation" in str(exc_info.value)
    assert len(exc_info.value.exceptions) == 2


async def test_get_ldap_dn(dataloader: DataLoader):
    with patch(
        "mo_ldap_import_export.dataloaders.single_object_search",
        return_value={"dn": "CN=foo"},
    ):
        assert await dataloader.get_ldap_dn(uuid4()) == "CN=foo"


async def test_get_ldap_unique_ldap_uuid(dataloader: DataLoader):
    uuid = uuid4()
    dataloader.load_ldap_object = AsyncMock()  # type: ignore
    dataloader.load_ldap_object.return_value = LdapObject(
        dn="foo", objectGUID=str(uuid)
    )

    assert await dataloader.get_ldap_unique_ldap_uuid("") == uuid


async def test_get_ldap_unique_ldap_uuid_no_objectguid(dataloader: DataLoader):
    dataloader.load_ldap_object = AsyncMock()  # type: ignore
    dataloader.load_ldap_object.return_value = LdapObject(dn="foo", objectGUID=[])

    with pytest.raises(NoObjectsReturnedException):
        await dataloader.get_ldap_unique_ldap_uuid("")


async def test_load_ldap_attribute_values(dataloader: DataLoader):
    responses = [
        {"attributes": {"foo": 1}},
        {"attributes": {"foo": "2"}},
        {"attributes": {"foo": []}},
    ]
    with patch(
        "mo_ldap_import_export.routes.paged_search",
        return_value=responses,
    ):
        values = await load_ldap_attribute_values(dataloader.context, "foo")
        assert "1" in values
        assert "2" in values
        assert "[]" in values
        assert len(values) == 3


async def test_create_mo_class(dataloader: DataLoader):
    uuid = uuid4()
    existing_class_uuid = uuid4()

    async def class_create(_) -> ClassCreateClassCreate:
        # Simulate creation time delay
        await asyncio.sleep(0.1)
        return ClassCreateClassCreate(uuid=uuid)

    dataloader.graphql_client.class_create.side_effect = class_create  # type: ignore

    class_not_found_response = ReadClassUuidClasses(objects=[])
    class_exists_response = ReadClassUuidClasses(
        objects=[ReadClassUuidClassesObjects(uuid=existing_class_uuid)]
    )

    # Case1: The class does not exist yet
    dataloader.graphql_client.read_class_uuid.return_value = class_not_found_response  # type: ignore
    assert await dataloader.create_mo_class("", "", uuid4()) == uuid

    # Case2: The class already exists
    dataloader.graphql_client.read_class_uuid.return_value = class_exists_response  # type: ignore
    assert await dataloader.create_mo_class("", "", uuid4()) == existing_class_uuid

    # Case3: We call the function twice and the first one needs to wait for the second
    dataloader.graphql_client.read_class_uuid.return_value = class_not_found_response  # type: ignore

    # Because of the lock, only one instance can run at the time.
    t1 = time.time()
    await asyncio.gather(
        dataloader.create_mo_class("n", "user_key", uuid4()),
        dataloader.create_mo_class("n", "user_key", uuid4()),
    )
    t2 = time.time()
    assert (t2 - t1) > 0.2  # each task takes 0.1 second


async def test_create_mo_job_function(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    route = graphql_mock.query("read_class_uuid_by_facet_and_class_user_key")
    route.result = {"classes": {"objects": []}}

    uuid1 = uuid4()
    uuid2 = uuid4()

    dataloader.load_mo_facet_uuid = AsyncMock()  # type: ignore
    dataloader.load_mo_facet_uuid.return_value = uuid1

    dataloader.create_mo_class = AsyncMock()  # type: ignore
    dataloader.create_mo_class.return_value = uuid2

    assert await get_or_create_job_function_uuid(dataloader, "foo") == str(uuid2)
    assert await get_or_create_engagement_type_uuid(dataloader, "bar") == str(uuid2)

    kwargs = dataloader.create_mo_class.call_args_list[0].kwargs
    assert kwargs == {"name": "foo", "user_key": "foo", "facet_uuid": uuid1}

    kwargs = dataloader.create_mo_class.call_args_list[1].kwargs
    assert kwargs == {"name": "bar", "user_key": "bar", "facet_uuid": uuid1}


async def test_load_mo_facet_uuid(dataloader: DataLoader, graphql_mock: GraphQLMocker):
    uuid = uuid4()

    route = graphql_mock.query("read_facet_uuid")
    route.result = {"facets": {"objects": [{"uuid": uuid}]}}
    assert await dataloader.load_mo_facet_uuid("") == uuid
    assert route.called


async def test_load_mo_facet_uuid_multiple_facets(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
):
    route = graphql_mock.query("read_facet_uuid")
    route.result = {
        "facets": {
            "objects": [
                {"uuid": uuid4()},
                {"uuid": uuid4()},
            ]
        }
    }
    with pytest.raises(MultipleObjectsReturnedException):
        await dataloader.load_mo_facet_uuid("")
    assert route.called


async def test_load_mo_facet_uuid_no_result(dataloader: DataLoader):
    dataloader.graphql_client.read_facet_uuid.return_value = parse_obj_as(  # type: ignore
        ReadFacetUuidFacets, {"objects": []}
    )
    result = await dataloader.load_mo_facet_uuid("")
    assert result is None


async def test_add_ldap_object(dataloader: DataLoader) -> None:
    dataloader.ldap_connection.get_response.return_value = [], {"type": "test"}

    await dataloader.add_ldap_object("CN=foo", attributes={"foo": 2})
    dataloader.ldap_connection.add.assert_called_once()

    dataloader.user_context["settings"] = MagicMock()  # type: ignore
    dataloader.user_context["settings"].add_objects_to_ldap = False
    dataloader.user_context["settings"].ldap_read_only = False

    with pytest.raises(ReadOnlyException) as exc:
        await dataloader.add_ldap_object("CN=foo")
    assert "Adding LDAP objects is disabled" in str(exc.value)

    dataloader.ldap_connection.reset_mock()
    dataloader.user_context["settings"].add_objects_to_ldap = True
    dataloader.ou_in_ous_to_write_to = MagicMock()  # type: ignore
    dataloader.ou_in_ous_to_write_to.return_value = False

    with pytest.raises(ReadOnlyException) as exc:
        await dataloader.add_ldap_object("CN=foo")
    assert "Not allowed to write to the specified OU" in str(exc.value)

    dataloader.user_context["settings"].ldap_read_only = True
    with pytest.raises(ReadOnlyException) as exc:
        await dataloader.add_ldap_object("CN=foo")
    assert "LDAP connection is read-only" in str(exc.value)


async def test_load_mo_employee_engagement_dicts(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    engagement1 = jsonable_encoder(
        {
            "uuid": uuid4(),
            "user_key": "foo",
            "org_unit_uuid": uuid4(),
            "job_function_uuid": uuid4(),
            "engagement_type_uuid": uuid4(),
            "primary_uuid": None,
        }
    )
    engagement2 = jsonable_encoder(
        {
            "uuid": uuid4(),
            "user_key": "foo",
            "org_unit_uuid": uuid4(),
            "job_function_uuid": uuid4(),
            "engagement_type_uuid": uuid4(),
            "primary_uuid": None,
        }
    )

    route = graphql_mock.query("read_engagements_by_engagements_filter")
    route.result = {
        "engagements": {"objects": [{"current": engagement1}, {"current": engagement2}]}
    }

    result = await dataloader.load_mo_employee_engagement_dicts(uuid4(), "foo")

    assert engagement1 in result
    assert engagement2 in result
    assert route.called

    route.reset()
    route.result = {"engagements": {"objects": []}}
    result = await dataloader.load_mo_employee_engagement_dicts(uuid4(), "foo")

    assert isinstance(result, list)
    assert len(result) == 0
    assert route.called


def test_ou_in_ous_to_write_to(dataloader: DataLoader):
    settings_mock = MagicMock()
    settings_mock.ldap_ous_to_write_to = ["OU=foo", "OU=mucki,OU=bar"]
    dataloader.user_context["settings"] = settings_mock

    assert dataloader.ou_in_ous_to_write_to("CN=Tobias,OU=foo,DC=k") is True
    assert dataloader.ou_in_ous_to_write_to("CN=Tobias,OU=bar,DC=k") is False
    assert dataloader.ou_in_ous_to_write_to("CN=Tobias,OU=mucki,OU=bar,DC=k") is True
    assert dataloader.ou_in_ous_to_write_to("CN=Tobias,DC=k") is False

    settings_mock.ldap_ous_to_write_to = [""]
    dataloader.user_context["settings"] = settings_mock

    assert dataloader.ou_in_ous_to_write_to("CN=Tobias,OU=foo,DC=k") is True
    assert dataloader.ou_in_ous_to_write_to("CN=Tobias,OU=bar,DC=k") is True
    assert dataloader.ou_in_ous_to_write_to("CN=Tobias,OU=mucki,OU=bar,DC=k") is True
    assert dataloader.ou_in_ous_to_write_to("CN=Tobias,DC=k") is True


async def test_load_all_current_it_users_no_paged(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
) -> None:
    itsystem1_uuid = uuid4()

    route = graphql_mock.query("read_all_itusers")
    route.result = {
        "itusers": {
            "objects": [
                {
                    "validities": [
                        {
                            "itsystem_uuid": str(itsystem1_uuid),
                            "employee_uuid": str(uuid4()),
                            "user_key": "foo",
                        }
                    ]
                }
            ],
            "page_info": {"next_cursor": None},
        }
    }
    results = await load_all_current_it_users(dataloader.graphql_client, itsystem1_uuid)
    result = one(results)
    assert result["itsystem_uuid"] == str(itsystem1_uuid)
    assert result["user_key"] == "foo"


async def test_load_all_current_it_users_paged(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
) -> None:
    itsystem1_uuid = uuid4()

    query_results = [
        {
            "itusers": {
                "objects": [
                    {
                        "validities": [
                            {
                                "itsystem_uuid": str(itsystem1_uuid),
                                "employee_uuid": str(uuid4()),
                                "user_key": "foo",
                            }
                        ]
                    }
                ],
                "page_info": {
                    "next_cursor": "VGhlIGNha2UgaXMgYSBsaWUK"  # Fake cursor
                },
            }
        },
        {
            "itusers": {
                "objects": [
                    {
                        "validities": [
                            {
                                "itsystem_uuid": str(itsystem1_uuid),
                                "employee_uuid": str(uuid4()),
                                "user_key": "bar",
                            }
                        ]
                    }
                ],
                "page_info": {"next_cursor": None},
            }
        },
    ]

    def pager(_: Any, route: Any) -> Response:
        # Gets called once per GraphQL httpx request
        # Each call increments route.call_count by one
        result = query_results[route.call_count]
        return Response(200, json={"data": jsonable_encoder(result)})

    route = graphql_mock.query("read_all_itusers")
    route.mock(side_effect=pager)
    results = await load_all_current_it_users(dataloader.graphql_client, itsystem1_uuid)
    assert len(results) == 2

    first, second = results
    assert first["itsystem_uuid"] == str(itsystem1_uuid)
    assert first["user_key"] == "foo"

    assert second["itsystem_uuid"] == str(itsystem1_uuid)
    assert second["user_key"] == "bar"


uuid_obj1 = uuid4()
uuid_obj2 = uuid4()
uuid_obj3 = uuid4()


@freeze_time("2022-08-10")
@pytest.mark.parametrize(
    "validities,expected",
    [
        # One of the objects is valid today - return it
        (
            [
                {
                    "validity": {
                        "from": "2022-08-01T00:00:00+02:00",
                        "to": "2022-08-02T00:00:00+02:00",
                    },
                    "uuid": uuid_obj1,
                },
                {
                    "validity": {
                        "from": "2022-08-02T00:00:00+02:00",
                        "to": "2022-08-15T00:00:00+02:00",
                    },
                    "uuid": uuid_obj2,
                },
                {
                    "validity": {
                        "from": "2022-08-15T00:00:00+02:00",
                        "to": None,
                    },
                    "uuid": uuid_obj3,
                },
            ],
            uuid_obj2,
        ),
        # One of the objects is valid all the time - return it
        (
            [
                # NOTE: This combination should never exist, but we wanna test the codepath
                {
                    "validity": {
                        "from": "2022-08-01T00:00:00+02:00",
                        "to": "2022-08-02T00:00:00+02:00",
                    },
                    "uuid": uuid_obj1,
                },
                {
                    "validity": {
                        "from": None,
                        "to": None,
                    },
                    "uuid": uuid_obj3,
                },
            ],
            uuid_obj3,
        ),
        # No object is valid today - return the latest
        (
            [
                {
                    "validity": {
                        "from": "2022-08-01T00:00:00+02:00",
                        "to": "2022-08-02T00:00:00+02:00",
                    },
                    "uuid": uuid_obj1,
                },
                {
                    "validity": {
                        "from": "2022-08-15T00:00:00+02:00",
                        "to": None,
                    },
                    "uuid": uuid_obj3,
                },
            ],
            uuid_obj3,
        ),
        # No valid current object - return the latest
        (
            [
                {
                    "validity": {
                        "from": "2022-08-01T00:00:00+02:00",
                        "to": "2022-08-02T00:00:00+02:00",
                    },
                    "uuid": uuid_obj1,
                },
                {
                    "validity": {
                        "from": "2022-08-15T00:00:00+02:00",
                        "to": "2022-08-20T00:00:00+02:00",
                    },
                    "uuid": uuid_obj2,
                },
            ],
            uuid_obj2,
        ),
        # One of the objects is valid today (without to-date) - return it
        (
            [
                {
                    "validity": {
                        "from": "2022-08-01T00:00:00+02:00",
                        "to": "2022-08-02T00:00:00+02:00",
                    },
                    "uuid": uuid_obj1,
                },
                {
                    "validity": {
                        "from": "2022-08-02T00:00:00+02:00",
                        "to": None,
                    },
                    "uuid": uuid_obj2,
                },
            ],
            uuid_obj2,
        ),
        # One of the objects is valid today (without from-date)- return it
        (
            [
                {
                    "validity": {
                        "from": None,
                        "to": "2022-08-15T00:00:00+02:00",
                    },
                    "uuid": uuid_obj2,
                },
                {
                    "validity": {
                        "from": "2022-08-15T00:00:00+02:00",
                        "to": None,
                    },
                    "uuid": uuid_obj3,
                },
            ],
            uuid_obj2,
        ),
    ],
)
def test_extract_latest_object(
    validities: list[dict[str, Any]], expected: UUID
) -> None:
    class Validity(BaseModel):
        from_: datetime.datetime | None = Field(alias="from")
        to: datetime.datetime | None

    class ValidityUUID(BaseModel):
        uuid: UUID
        validity: Validity

    obj_validities = parse_obj_as(list[ValidityUUID], validities)
    result = extract_current_or_latest_validity(obj_validities)
    assert result is not None
    assert result.uuid == expected


def test_extract_latest_object_empty() -> None:
    with pytest.raises(NoObjectsReturnedException):
        extract_current_or_latest_validity([])


async def test_load_mo_root_org_uuid(graphql_mock: GraphQLMocker) -> None:
    graphql_client = GraphQLClient("http://example.com/graphql")
    root_org_uuid = uuid4()

    route = graphql_mock.query("read_root_org_uuid")
    route.result = {"org": {"uuid": root_org_uuid}}

    assert await load_mo_root_org_uuid(graphql_client) == root_org_uuid


def test_decompose_ou_string(dataloader: DataLoader):
    ou = "OU=foo,OU=mucki,OU=bar"
    output = dataloader.decompose_ou_string(ou)

    assert len(output) == 3
    assert output[0] == "OU=foo,OU=mucki,OU=bar"
    assert output[1] == "OU=mucki,OU=bar"
    assert output[2] == "OU=bar"


async def test_create_ou(dataloader: DataLoader) -> None:
    dataloader.ldap_connection.get_response.return_value = [], {"type": "test"}

    dataloader.load_ldap_OUs = AsyncMock()  # type: ignore
    dataloader.ou_in_ous_to_write_to = MagicMock()  # type: ignore
    dataloader.ou_in_ous_to_write_to.return_value = True

    settings_mock = MagicMock()
    settings_mock.ldap_search_base = "DC=Magenta"
    dataloader.user_context["settings"] = settings_mock  # type: ignore
    dataloader.user_context["settings"].ldap_read_only = False

    dataloader.load_ldap_OUs.return_value = {
        "OU=mucki,OU=bar": {"empty": False},
        "OU=bar": {"empty": False},
    }

    ou = "OU=foo,OU=mucki,OU=bar"
    await dataloader.create_ou(ou)
    dataloader.ldap_connection.add.assert_called_once_with(
        "OU=foo,OU=mucki,OU=bar,DC=Magenta", "OrganizationalUnit", None
    )

    dataloader.user_context["settings"].add_objects_to_ldap = False

    with pytest.raises(ReadOnlyException) as exc:
        await dataloader.create_ou(ou)
    assert "Adding LDAP objects is disabled" in str(exc.value)

    dataloader.ldap_connection.reset_mock()
    dataloader.user_context["settings"].add_objects_to_ldap = True
    dataloader.ou_in_ous_to_write_to.return_value = False

    await dataloader.create_ou(ou)
    dataloader.ldap_connection.add.assert_not_called()

    dataloader.user_context["settings"].ldap_read_only = True
    with pytest.raises(ReadOnlyException) as exc:
        await dataloader.create_ou(ou)
    assert "LDAP connection is read-only" in str(exc.value)


async def test_delete_ou(dataloader: DataLoader) -> None:
    dataloader.ldap_connection.get_response.return_value = [], {"type": "test"}

    dataloader.load_ldap_OUs = AsyncMock()  # type: ignore
    dataloader.ou_in_ous_to_write_to = MagicMock()  # type: ignore
    dataloader.ou_in_ous_to_write_to.return_value = True

    settings_mock = MagicMock()
    settings_mock.ldap_search_base = "DC=Magenta"
    dataloader.user_context["settings"] = settings_mock  # type: ignore
    dataloader.user_context["settings"].ldap_read_only = False

    dataloader.load_ldap_OUs.return_value = {
        "OU=foo,OU=mucki,OU=bar": {"empty": True},
        "OU=mucki,OU=bar": {"empty": False},
        "OU=bar": {"empty": False},
    }

    ou = "OU=foo,OU=mucki,OU=bar"
    await dataloader.delete_ou(ou)
    dataloader.ldap_connection.delete.assert_called_once_with(
        "OU=foo,OU=mucki,OU=bar,DC=Magenta"
    )

    dataloader.ldap_connection.reset_mock()
    dataloader.user_context["settings"].add_objects_to_ldap = True
    dataloader.ou_in_ous_to_write_to.return_value = False

    await dataloader.delete_ou(ou)
    dataloader.ldap_connection.delete.assert_not_called()

    # Test that we do not remove the ou-for-new-users
    dataloader.ou_in_ous_to_write_to.return_value = True
    settings_mock.ldap_ou_for_new_users = ou
    await dataloader.delete_ou(ou)
    dataloader.ldap_connection.delete.assert_not_called()

    # Test that we do not try to remove an OU which is not in the ou-dict
    dataloader.ou_in_ous_to_write_to.return_value = False
    await dataloader.delete_ou("OU=non_existing_OU")
    dataloader.ldap_connection.delete.assert_not_called()

    dataloader.user_context["settings"].ldap_read_only = True
    with pytest.raises(ReadOnlyException) as exc:
        await dataloader.delete_ou("OU=non_existing_OU")
    assert "LDAP connection is read-only" in str(exc.value)


async def test_move_ldap_object(dataloader: DataLoader):
    dataloader.ou_in_ous_to_write_to = MagicMock()  # type: ignore
    dataloader.ou_in_ous_to_write_to.return_value = True
    settings_mock = MagicMock()
    dataloader.user_context["settings"] = settings_mock  # type: ignore
    dataloader.user_context["settings"].ldap_read_only = False
    dataloader.ldap_connection.get_response.return_value = (
        [],
        {"description": "success"},
    )

    success = await dataloader.move_ldap_object("CN=foo,OU=old_ou", "CN=foo,OU=new_ou")

    dataloader.ldap_connection.modify_dn.assert_called_once_with(
        "CN=foo,OU=old_ou", "CN=foo", new_superior="OU=new_ou"
    )
    assert success is True

    dataloader.ou_in_ous_to_write_to.return_value = False
    success = await dataloader.move_ldap_object("CN=foo,OU=old_ou", "CN=foo,OU=new_ou")
    assert success is False

    dataloader.ou_in_ous_to_write_to.return_value = True
    dataloader.user_context["settings"].add_objects_to_ldap = False

    with pytest.raises(ReadOnlyException) as exc:
        await dataloader.move_ldap_object("CN=foo,OU=old_ou", "CN=foo,OU=new_ou")
    assert "Adding LDAP objects is disabled" in str(exc.value)

    dataloader.user_context["settings"].add_objects_to_ldap = True
    dataloader.user_context["settings"].ldap_read_only = True
    with pytest.raises(ReadOnlyException) as exc:
        await dataloader.move_ldap_object("CN=foo,OU=old_ou", "CN=foo,OU=new_ou")
    assert "LDAP connection is read-only" in str(exc.value)


async def test_find_mo_engagement_uuid(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    """Check that `find_mo_engagement_uuid` returns the expected engagement UUID, by
    looking at any previously created "ADGUID" `ITUser` objects in MO for the given
    employee.
    """

    # Arrange
    object_guid: UUID = uuid4()
    engagement_uuid: UUID = uuid4()
    itsystem_uuid: UUID = uuid4()
    mock_ldap_object: LdapObject = LdapObject(
        dn="CN=foo", objectGUID=f"{{{object_guid}}}"
    )

    dataloader.get_ldap_it_system_uuid = AsyncMock()  # type: ignore
    dataloader.get_ldap_it_system_uuid.return_value = None
    with patch.object(dataloader, "load_ldap_object", return_value=mock_ldap_object):
        # Act
        empty = await dataloader.find_mo_engagement_uuid("CN=foo")
        # Assert
        assert empty is None

    dataloader.get_ldap_it_system_uuid.return_value = str(itsystem_uuid)

    route = graphql_mock.query("read_engagement_uuid_by_ituser_user_key")
    route.result = {
        "itusers": {"objects": [{"current": {"engagement_uuid": engagement_uuid}}]}
    }
    with patch.object(dataloader, "load_ldap_object", return_value=mock_ldap_object):
        # Act
        actual_engagement_uuid = await dataloader.find_mo_engagement_uuid("CN=foo")
        # Assert
        assert actual_engagement_uuid == engagement_uuid
    assert route.called

    # Test behavior if MO has no IT users for the given employee
    route.reset()
    route.result = {"itusers": {"objects": []}}
    with patch.object(dataloader, "load_ldap_object", return_value=mock_ldap_object):
        # Act
        empty = await dataloader.find_mo_engagement_uuid("CN=foo")
        # Assert
        assert empty is None
    assert route.called


async def test_create_or_edit_mo_objects_empty(
    dataloader: DataLoader,
    legacy_model_client: AsyncMock,
) -> None:
    # *Empty* list of object/verb pairs.
    await dataloader.create_or_edit_mo_objects([])
    legacy_model_client.upload.assert_not_called()
    legacy_model_client.edit.assert_not_called()


async def test_create_or_edit_mo_objects(dataloader: DataLoader) -> None:
    # One object is created and another is edited.
    create = MagicMock()
    del create.terminate_

    edit = MagicMock()
    del edit.terminate_

    terminate = MagicMock()

    objs = [(create, Verb.CREATE), (edit, Verb.EDIT), (terminate, Verb.TERMINATE)]

    dataloader.create = AsyncMock()  # type: ignore
    dataloader.edit = AsyncMock()  # type: ignore
    dataloader.terminate = AsyncMock()  # type: ignore

    await dataloader.create_or_edit_mo_objects(objs)  # type: ignore
    dataloader.create.assert_called_once_with([create])
    dataloader.edit.assert_called_once_with([edit])
    dataloader.terminate.assert_called_once_with([terminate])


async def test_create_objects(
    dataloader: DataLoader,
    legacy_model_client: AsyncMock,
) -> None:
    create = gen_address("test")

    objs = [(create, Verb.CREATE)]

    legacy_model_client.upload.return_value = [uuid4()]

    await dataloader.create_or_edit_mo_objects(objs)  # type: ignore
    legacy_model_client.upload.assert_called_once_with([create])


async def test_edit_objects(
    dataloader: DataLoader, legacy_model_client: AsyncMock
) -> None:
    edit = gen_address("test")

    objs = [(edit, Verb.EDIT)]

    legacy_model_client.edit.return_value = [uuid4()]

    await dataloader.create_or_edit_mo_objects(objs)  # type: ignore
    legacy_model_client.edit.assert_called_once_with([edit])


@pytest.mark.parametrize(
    "motype,term_name",
    [
        ("address", "address_terminate"),
        ("engagement", "engagement_terminate"),
        ("it", "ituser_terminate"),
    ],
)
async def test_terminate_objects(
    dataloader: DataLoader, motype: str, term_name: str
) -> None:
    # One object is created and another is edited.
    terminate = MagicMock()
    terminate.type_ = motype
    terminate.uuid = uuid4()

    objs = [(terminate, Verb.TERMINATE)]

    await dataloader.create_or_edit_mo_objects(objs)  # type: ignore
    getattr(dataloader.graphql_client, term_name).assert_called_once()


async def test_terminate_unknown_type(dataloader: DataLoader) -> None:
    # One object is created and another is edited.
    terminate = MagicMock()
    terminate.type_ = "gaxi"
    terminate.uuid = uuid4()

    objs = [(terminate, Verb.TERMINATE)]

    with pytest.raises(ExceptionGroup) as exc_info:
        await dataloader.create_or_edit_mo_objects(objs)  # type: ignore
    assert "Exceptions during termination" in str(exc_info.value)
    assert "Unable to terminate type: gaxi" in str(one(exc_info.value.exceptions))


async def test_terminate_fix_verb(
    dataloader: DataLoader,
    legacy_model_client: AsyncMock,
) -> None:
    """Test that our hacky code makes terminates Verb.TERMINATE."""
    terminate = MagicMock()
    terminate.terminate_ = datetime.datetime.now().isoformat()
    terminate.type_ = "address"
    terminate.uuid = uuid4()

    # This Verb.EDIT becomes Verb.TERMINATE because of the terminate_ field
    objs = [(terminate, Verb.EDIT)]

    await dataloader.create_or_edit_mo_objects(objs)  # type: ignore
    legacy_model_client.create.assert_not_called()
    legacy_model_client.edit.assert_not_called()
    dataloader.graphql_client.address_terminate.assert_called_once()  # type: ignore


@pytest.mark.parametrize(
    "cpr_number,dns,expected",
    [
        # No CPR number -> no DNs
        (None, None, set()),
        # CPR number, but no accounts -> no DNs
        ("0101700000", [], set()),
        # CPR number and one account -> one DN
        ("0101700000", ["CN=foo"], {"CN=foo"}),
        # CPR number and two accounts -> two DN
        ("0101700000", ["CN=foo", "CN=bar"], {"CN=foo", "CN=bar"}),
    ],
)
async def test_find_mo_employee_dn_by_cpr_number(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
    cpr_number: str | None,
    dns: list[str] | None,
    expected: set[str] | str,
) -> None:
    employee_uuid = uuid4()
    employee = {
        "uuid": employee_uuid,
        "cpr_no": cpr_number,
        "givenname": "first_name",
        "surname": "last_name",
        "nickname_givenname": None,
        "nickname_surname": None,
        "validity": {"to": None},
    }
    route = graphql_mock.query("read_employees")
    route.result = {"employees": {"objects": [{"validities": [employee]}]}}

    dataloader.load_ldap_cpr_object = AsyncMock()  # type: ignore
    dataloader.load_ldap_cpr_object.return_value = [
        parse_obj_as(LdapObject, {"dn": dn}) for dn in (dns or [])
    ]

    result = await dataloader.find_mo_employee_dn_by_cpr_number(employee_uuid)
    assert result == expected

    if dns is not None:
        dataloader.load_ldap_cpr_object.assert_called_once_with(cpr_number, "Employee")


async def test_find_mo_employee_dn_by_itsystem_no_itsystem(
    dataloader: DataLoader,
) -> None:
    employee_uuid = uuid4()

    dataloader.get_ldap_it_system_uuid = AsyncMock()  # type: ignore
    dataloader.get_ldap_it_system_uuid.return_value = None

    result = await dataloader.find_mo_employee_dn_by_itsystem(employee_uuid)
    assert result == set()


async def test_find_mo_employee_dn_by_itsystem_no_match(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
) -> None:
    employee_uuid = uuid4()
    itsystem_uuid = uuid4()

    dataloader.get_ldap_it_system_uuid = AsyncMock()  # type: ignore
    dataloader.get_ldap_it_system_uuid.return_value = str(itsystem_uuid)

    route1 = graphql_mock.query("read_ituser_by_employee_and_itsystem_uuid")
    route1.result = {"itusers": {"objects": []}}

    result = await dataloader.find_mo_employee_dn_by_itsystem(employee_uuid)
    assert result == set()


async def test_find_mo_employee_dn_by_itsystem(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
) -> None:
    employee_uuid = uuid4()
    itsystem_uuid = uuid4()
    ituser_uuid = uuid4()

    dataloader.get_ldap_it_system_uuid = AsyncMock()  # type: ignore
    dataloader.get_ldap_it_system_uuid.return_value = str(itsystem_uuid)

    route1 = graphql_mock.query("read_ituser_by_employee_and_itsystem_uuid")
    route1.result = {"itusers": {"objects": [{"uuid": ituser_uuid}]}}

    route2 = graphql_mock.query("read_itusers")
    route2.result = {
        "itusers": {
            "objects": [
                {
                    "validities": [
                        {
                            "user_key": ituser_uuid,
                            "validity": {"from": "1970-01-01T00:00:00Z"},
                            "employee_uuid": employee_uuid,
                            "itsystem_uuid": itsystem_uuid,
                            "engagement_uuid": None,
                        }
                    ]
                }
            ]
        }
    }

    dn = "CN=foo"
    dataloader.get_ldap_dn = AsyncMock()  # type: ignore
    dataloader.get_ldap_dn.return_value = dn

    result = await dataloader.find_mo_employee_dn_by_itsystem(employee_uuid)
    assert result == {dn}

    dataloader.get_ldap_dn.assert_called_once_with(ituser_uuid)


async def test_create_exceptions(
    dataloader: DataLoader,
    legacy_model_client: AsyncMock,
) -> None:
    """Test that trying to create with exceptions reraise exceptions."""
    legacy_model_client.upload.side_effect = ValueError("BOOM")

    obj = gen_ituser("1")

    with pytest.raises(ExceptionGroup) as exc_info:
        await dataloader.create([obj])
    assert "Exceptions during creation" in str(exc_info.value)


async def test_edit_exceptions(
    dataloader: DataLoader,
    legacy_model_client: AsyncMock,
) -> None:
    """Test that trying to edit with exceptions reraise exceptions."""
    legacy_model_client.edit.side_effect = ValueError("BOOM")

    obj = gen_ituser("1")

    with pytest.raises(ExceptionGroup) as exc_info:
        await dataloader.edit([obj])
    assert "Exceptions during modification" in str(exc_info.value)


async def test_create_unknown_type(dataloader: DataLoader) -> None:
    """Test that trying to create an unknown type throws an exception."""
    unknown_type = MagicMock()
    unknown_type.type_ = "faceless"

    with pytest.raises(NotImplementedError) as exc_info:
        await dataloader.create_object(unknown_type)
    assert "Unable to create type: faceless" in str(exc_info.value)


async def test_edit_unknown_type(dataloader: DataLoader) -> None:
    """Test that trying to edit an unknown type throws an exception."""
    unknown_type = MagicMock()
    unknown_type.type_ = "faceless"

    with pytest.raises(NotImplementedError) as exc_info:
        await dataloader.edit_object(unknown_type)
    assert "Unable to edit type: faceless" in str(exc_info.value)


@pytest.mark.parametrize(
    "obj",
    [
        gen_ituser("1"),
        gen_address("2"),
        gen_engagement("3"),
        gen_employee("4"),
    ],
)
async def test_create_each_type(
    legacy_model_client: AsyncMock, dataloader: DataLoader, obj: MOBase
) -> None:
    create_uuid = uuid4()

    legacy_model_client.upload.return_value = [create_uuid]

    result = await dataloader.create_object(obj)
    assert result == create_uuid
    legacy_model_client.upload.assert_called_once()


@pytest.mark.parametrize(
    "obj",
    [
        gen_ituser("1"),
        gen_address("2"),
        gen_engagement("3"),
        gen_employee("4"),
    ],
)
async def test_edit_each_type(
    legacy_model_client: AsyncMock, dataloader: DataLoader, obj: MOBase
) -> None:
    edit_uuid = uuid4()

    legacy_model_client.edit.return_value = [edit_uuid]

    result = await dataloader.edit_object(obj)
    assert result == edit_uuid
    legacy_model_client.edit.assert_called_once()


async def test_create_org_unit(
    legacy_model_client: AsyncMock, dataloader: DataLoader
) -> None:
    org_unit = gen_org_unit("5")

    create_uuid = uuid4()

    legacy_model_client.upload.return_value = [create_uuid]

    result = await dataloader.create_org_unit(org_unit)
    assert result == create_uuid
    legacy_model_client.upload.assert_called_once()
